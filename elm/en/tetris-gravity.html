<!doctype html>
<html lang="en" domain="blog.axelerator.de" >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/assets/js/highlight/styles/default.css">
    <link rel="stylesheet" href="/assets/css/tufte.min.css"/>
    <link rel="stylesheet" href="/assets/css/styles.css"/>
    <link rel="icon" type="image/png" href="/favicon.png">
    <title>Episode 4: Applying 'gravity' to the current piece with subscriptions</title>
  </head>
  <body class="tetris-gravity">
    <header>
      <div id="bg">axelerator.de</div>
      <nav>
  <div class="pages">
  
    <div><a href="/">Home</a></div>
  
    <div><a href="/about">About</a></div>
  
  </div>
  <div class="links">
    <a href="/feed.xml"><span class="rss"/></a>
    <a href="https://twitter.com/TheAxelerator"><span class="twitter"/></a>
    <a href="https://github.com/axelerator"><span class="github"/></a>
    <a href="https://www.linkedin.com/in/axel-tetzlaff"><span class="linkedin"/></a>
    <a href="https://www.youtube.com/channel/UCQFzW6LFfreLOYI9-3QV2xg"><span class="youtube"/></a>
    <a href="https://www.twitch.tv/programmingisfun"><span class="twitch"/></a>
  </div>
  <div id="lang-picker">
    <label class="current" for="lang-toggle">ðŸ‡ºðŸ‡¸</label>
    <input type="checkbox" id="lang-toggle">
    <ul>
      
      
        
          <li>
            <a href="/elm/de/tetris-gravity" class="de">ðŸ‡©ðŸ‡ª</a>
          </li>
        
      
        
      
    </ul>

  </div>

</nav>




    </header>
    <main>
     <article>
       <h1>Episode 4: Applying 'gravity' to the current piece with subscriptions</h1>
       
<label for="post-meta" class="margin-toggle">&#8853;</label>
<input type="checkbox" id="post-meta"  class="margin-toggle"/>
<span class="marginnote">
24 July 2021
<br/>

  
  <a href="/tags#elm">elm</a>

</span>



<section>
<section>
<p>After the marathon episode last week I kept it to more digestible 30 minutes this time.</p>

<p>The goal was to have the current piece drop by one row every second.</p>

<p>I added the necessary types and property to the <code class="language-plaintext highlighter-rouge">Model</code> to store the position, but more interestingly I started to use <a href="https://guide.elm-lang.org/effects/">â€˜subscriptionsâ€™</a> to updated it every second.</p>

<p>The changes made in this episode are available on Github: <a href="https://github.com/axelerator/elm-tetris/tree/episode4">Branch Episode4</a> <a href="https://github.com/axelerator/elm-tetris/commit/d1b908b4f0dee9e4b58b1e3e4c48c6bdc2b45465">Commit</a></p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZzvUUi4Hv04" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>To trigger an event every second in Elm we have to understand how <strong>subscriptions</strong> work in Elm. They have been a part of our application definition from the beginning. But we got away with ignoring them because they were empty (<code class="language-plaintext highlighter-rouge">Sub.none</code>)</p>

<pre><code class="language-Elm">main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }

subscriptions : Model -&gt; Sub Msg
subscriptions model =
    Sub.none
</code></pre>

<p>To understand how they fit with the elements we already know, letâ€™s revisit the system as far as we know it:</p>

<p><img src="/assets/posts/tetris-gravity/elmloop.svg" alt="Elm application loop" /></p>

<ol>
  <li>The application starts with the state generated by the <code class="language-plaintext highlighter-rouge">init</code> function that we defined</li>
  <li>The <code class="language-plaintext highlighter-rouge">view</code> function is used to create the initial Html tree that is going to be displayed</li>
  <li>Interactive UI elements like buttons generate Messages</li>
  <li>The <code class="language-plaintext highlighter-rouge">update</code> function calculates a new model based on a message and the old model state</li>
  <li><code class="language-plaintext highlighter-rouge">GOTO 2</code></li>
</ol>

<p>The beauty of this model is its simplicity. With the <code class="language-plaintext highlighter-rouge">update</code> function there is exactly one place in every Elm app where the application state is altered/calculated.
This makes it straight forward to understand and alter different Elm applications.
Vanilla JavaScript applications on the other have no restrictions on who changes what whatsoever.</p>

<p>The main challenge for such restricted systems is to still be able to write every possible application.
One scenario that can not be expressed in the <code class="language-plaintext highlighter-rouge">init-&gt;view-&gt;update</code> model weâ€™ve expressed so far is the one we want to look at now:</p>

<blockquote>
  <p>Every second the position of the current Tetris piece should be lowered by one row</p>
</blockquote>

<p>In vanilla JavaScript we would use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval#example_1_basic_syntax"><code class="language-plaintext highlighter-rouge">setInterval</code> function</a> that comes with the browser</p>

<p>But Elm deliberately forbids calling JavaScript functions directly. One reason for that is, that we want to maintain the rule that the model is only ever â€˜alteredâ€™ from the <code class="language-plaintext highlighter-rouge">update</code> function. So even if we could register something with <code class="language-plaintext highlighter-rouge">setInterval</code> we would not be able to modify the <code class="language-plaintext highlighter-rouge">model</code> directly.</p>

<p>So since we know we want to modify the position, so ultimately the model we know <em>have to</em> add a new branch to our update function.
For that we extend our message type <code class="language-plaintext highlighter-rouge">Msg</code> with a new variant <code class="language-plaintext highlighter-rouge">GravityTick</code>.
Now we can handle that new variant in our update function to calculate a new model state with the update piece position:</p>

<pre><code class="language-Elm">type Msg = ... | GravityTick 


update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GravityTick -&gt;
            ( dropCurrentPiece model
            , Cmd.none
            )

dropCurrentPiece : Model -&gt; Model
dropCurrentPiece model = ...
</code></pre>

<p>So far so good, but how do we <strong>produce</strong> this new message? So far we only learned how to produce messages from interactive elements like <a href="https://guide.elm-lang.org/architecture/buttons.html">&lt;<code class="language-plaintext highlighter-rouge">button&gt;</code></a>.</p>

<p>Thatâ€™s the moment where <strong>subscriptions</strong> come into play! With the <code class="language-plaintext highlighter-rouge">subscriptions</code> function thatâ€™s part of our application definition we can register sources of messages that are <strong>not</strong> triggered by the user directly.</p>

<pre><code class="language-Elm">main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }

subscriptions : Model -&gt; Sub Msg
subscriptions _ =
    Time.every 1000 GravityTick
</code></pre>

<p><img src="/assets/posts/tetris-gravity/elmloopsubs.svg" alt="Elm application loop" /></p>

<p>With the <a href="https://package.elm-lang.org/packages/elm/time/latest/Time#every"><code class="language-plaintext highlighter-rouge">every</code> function</a> that ships with the Elm core library we can generate such a source.</p>

<p><code class="language-plaintext highlighter-rouge">Time.every</code> gets called with a number of milliseconds that defines how often we want the message to be generated. The second parameter specifies <strong>which</strong> message will be sent.</p>

<p>But specifically the second parameter in the signature of every looks a bit more complicated than what Iâ€™ve described.</p>

<pre><code class="language-Elm">every : Float -&gt; (Posix -&gt; msg) -&gt; Sub msg
</code></pre>

<p>The second parameter is of type <code class="language-plaintext highlighter-rouge">(Posix -&gt; msg)</code> and thatâ€™s definitely not just a message!
That observation is correct and the reason for that is that <code class="language-plaintext highlighter-rouge">every</code> wants to pass on a bit of information along with our message: the current, absolute time.</p>

<p>The reason for that is that the browser cannot guarantee that the message is actually sent exactly every second. So for applications that want to track the passed time it is more precise to calculate that based on the timestamp that gets passed along.</p>

<p>For <code class="language-plaintext highlighter-rouge">every</code> to be able to pass the time with our message it needs to be passed <strong>a function</strong> that <strong>expects a time</strong> (<code class="language-plaintext highlighter-rouge">Posix</code>) and <strong>returns</strong> a message.</p>

<p>If we add <code class="language-plaintext highlighter-rouge">Posix</code> as parameter to our variant definition, the name of the variant serves as <em>constructor</em> of this variant. And its signature is exactly the one that <code class="language-plaintext highlighter-rouge">Time.every</code> asks for.
Thatâ€™s why we can just write <code class="language-plaintext highlighter-rouge">Time.every 1000 GravityTick</code> in this more complete example:</p>

<pre><code class="language-Elm">main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }

type Msg = .. | .. | GravityTick Posix | ..

subscriptions : Model -&gt; Sub Msg
subscriptions _ =
    Time.every 1000 GravityTick

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        GravityTick currentTime -&gt;
            ( computeNewModel currentTime
            , Cmd.none
            )
        ...
</code></pre>

<p>For our Tetris however weâ€™re not really interested in how much time elapsed, so you wont find it used in our actual code.</p>


</section>

</section>
<div id="remark42"></div>
<script>
  var remark_config = {
    host: 'https://comments.axelerator.de',
    site_id: 'comments',
  }
</script>
<script>!function(e,n){for(var o=0;o<e.length;o++){var r=n.createElement("script"),c=".js",d=n.head||n.body;"noModule"in r?(r.type="module",c=".mjs"):r.async=!0,r.defer=!0,r.src=remark_config.host+"/web/"+e[o]+c,d.appendChild(r)}}(remark_config.components||["embed"],document);</script>


     </article>
    </main>
  </body>
  <script src="/assets/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script data-goatcounter="https://goatcounter.axelerator.de/count"
        async src="//goatcounter.axelerator.de/count.js"></script>
</html>

