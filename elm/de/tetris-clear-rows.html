<!doctype html>
<html lang="en" domain="blog.axelerator.de" >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/assets/js/highlight/styles/default.css">
    <link rel="stylesheet" href="/assets/css/tufte.min.css"/>
    <link rel="stylesheet" href="/assets/css/styles.css"/>
    <link rel="icon" type="image/png" href="/favicon.png">
    <title>Episode 10: Komplette Reihen verschwinden mit Falten</title>
  </head>
  <body class="tetris-clear-rows">
    <header>
      <div id="bg">axelerator.de</div>
      <nav>
  <div class="pages">
  
    <div><a href="/de">Home</a></div>
  
    <div><a href="/√ºber">√úber</a></div>
  
  </div>
  <div class="links">
    <a href="/feed.xml"><span class="rss"/></a>
    <a href="https://twitter.com/TheAxelerator"><span class="twitter"/></a>
    <a href="https://hachyderm.io/@axelerator"><span class="fediverse"/></a>
    <a href="https://github.com/axelerator"><span class="github"/></a>
    <a href="https://www.linkedin.com/in/axel-tetzlaff"><span class="linkedin"/></a>
    <a href="https://www.youtube.com/channel/UCQFzW6LFfreLOYI9-3QV2xg"><span class="youtube"/></a>
    <a href="https://www.twitch.tv/programmingisfun"><span class="twitch"/></a>
  </div>
  <div id="lang-picker">
    <label class="current" for="lang-toggle">üá©üá™</label>
    <input type="checkbox" id="lang-toggle">
    <ul>
      
      
        
      
        
          <li>
            <a href="/elm/en/tetris-clear-rows" class="en">üá∫üá∏</a>
          </li>
        
      
    </ul>

  </div>

</nav>




    </header>
    <main>
     <article>
       <h1>Episode 10: Komplette Reihen verschwinden mit Falten</h1>
       <div class="meta"> 
  <div title="Lesedauer">4 Minuten</div>
  <div>
  
    
    <a href="/tags#elm">#elm</a>
  
  </div>
  <div>16 September 2021</div>
</div>


<section>
<p><img src="/assets/posts/tetris-clear-rows/teaser.gif" style="float:left; margin: 5px 10px 10px 0" />
Damit mein Tetris spielbar wird sorge ich in <a href="https://www.youtube.com/watch?v=b1vnT6XTFP4">Episode 10 (55min)</a> 
daf√ºr, dass vollst√§ndige Zeilen verschwinden. Mit mehr Unit-Tests und der Anwendung der Faltung einer Liste n√§here ich mich einem vollst√§ndigen Version.</p>

<p>Die Code-√Ñnderungen von dieser Woche gibt es im <a href="https://github.com/axelerator/elm-tetris/tree/episode10">episode10 Branch</a> bzw <a href="https://github.com/axelerator/elm-tetris/commit/74ac057b1037e10cd6c47b63647952c943054718">Commit</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/b1vnT6XTFP4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Es ist immer sehr befriedigend wenn man sich einen Plan zurechtlegt und die Ausf√ºhrung dann auch einigerma√üen danach abl√§uft.
Dementsprechend hat die Aufzeichnung dieser Episode auch Spa√ü gemacht. Die initiale Idee war es die <code class="language-plaintext highlighter-rouge">eraseCompleteRows</code> zu entwickeln, welche ein Board von den vollst√§ndigen Reihen befreien sollte.</p>

<p>Da ich bereits in <a href="/elm/de/tetris-collision">Episode 7</a> ein Setup f√ºr automatisierte Tests eingerichtet hatte, fiel die Entscheidung nicht schwer diesmal gleich mit einem Test loszulegen.</p>

<p>Der Algorithmus f√ºr den ich mich am Ende entschieden habe l√§uft wie folgt ab:</p>

<ol>
  <li>Durchlaufe alle Zeilen des Spielbretts:
    <ul>
      <li><em>1a</em> f√ºr eine <strong>unvollst√§ndige</strong> Reihe: Sammele sie als <em>‚ÄúBoden‚Äù</em>-Reihe f√ºr das Folgespielbrett</li>
      <li><em>1b</em> f√ºr eine <strong>vollst√§ndige</strong> Reihe: Sammel eine leere <em>‚ÄúKopf‚Äù</em>-Reihe in einer Extra-Liste</li>
    </ul>
  </li>
  <li>Erstelle das Folgespielbrett mit den <em>‚ÄúBoden‚Äù</em>-Reihen (1a) unten und h√§nge die <em>‚ÄúKopf‚Äù</em>-Reihen (1b) dar√ºber.</li>
</ol>

<p>Bei der Implementierung habe ich mich f√ºr die Nutzung der <code class="language-plaintext highlighter-rouge">foldr</code> Funktion entschieden. Da einige Programmierer Angst vor dieser Funktion zu haben scheinen m√∂chte ich hier die Gelegenheit nutzen ein paar Unklarheiten zu breinigen.</p>

<h3 id="wof√ºr-ist-foldr-gut">Wof√ºr ist <code class="language-plaintext highlighter-rouge">foldr</code> gut?</h3>

<p><code class="language-plaintext highlighter-rouge">foldr</code> existiert in vielen Sprachen, sie hei√üt nur manchmal anders:</p>

<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reduce</a> in JavaScript</li>
  <li><a href="https://ruby-doc.org/core-3.0.2/Enumerable.html#method-i-inject">inject</a> in Ruby</li>
</ul>

<p>√Ñhnlich wie <code class="language-plaintext highlighter-rouge">map</code> k√∂nnen wir <code class="language-plaintext highlighter-rouge">fold</code> eine Funktion als Parameter √ºbergeben, die f√ºr jedes Element ausgef√ºhrt wird. Im Gegensatz zu <code class="language-plaintext highlighter-rouge">map</code> braucht das Ergebnis allerdings nicht zwingend eine Liste zu sein, sonder kann von einem beliebigem Typ sein.
In diesem Sinne ist <code class="language-plaintext highlighter-rouge">fold</code> also <em>‚Äúm√§chtiger‚Äù</em> als <code class="language-plaintext highlighter-rouge">map</code>.</p>

<p>Diese Macht erkaufen wir uns allerdings auch mit etwas mehr Komplexit√§t. Vergleichen wir einmal die Signaturen von <code class="language-plaintext highlighter-rouge">map</code> und <code class="language-plaintext highlighter-rouge">foldr</code>:</p>

<pre><code class="language-Elm">map :   (a -&gt; b)             -&gt; List a -&gt; List b

foldr : (a -&gt; b -&gt; b)  -&gt;  b -&gt; List a -&gt; b
</code></pre>

<p><code class="language-plaintext highlighter-rouge">map</code> ist einfach: Es verwandelt eine Liste von Elementen vom typ <code class="language-plaintext highlighter-rouge">a</code> in eine gleich lange Liste von Elementen vom Typ <code class="language-plaintext highlighter-rouge">b</code>. Daf√ºr verwendet <code class="language-plaintext highlighter-rouge">map</code> die Funktion <code class="language-plaintext highlighter-rouge">(a -&gt; b)</code> die wir √ºbergeben.</p>

<p>Ich habe die einzelnen Parameter in Signaturen bewusst ausgerichtet um die Unterschiede zu verdeutlichen.
F√ºr <code class="language-plaintext highlighter-rouge">fold</code> taucht <code class="language-plaintext highlighter-rouge">b</code> jetzt an viel mehr Stellen auf! 
Der R√ºckgabewert ist jetzt nur noch <code class="language-plaintext highlighter-rouge">b</code> anstatt <code class="language-plaintext highlighter-rouge">List b</code>!
Unsere ‚ÄúFaltfunktion‚Äù ist nicht mehr <code class="language-plaintext highlighter-rouge">(a -&gt; b)</code> sondern <code class="language-plaintext highlighter-rouge">(a -&gt; b -&gt; b)</code>. Das hei√üt um den R√ºckggabewert <em>pro Element</em> zu berechnen m√ºssen wir zus√§tzlich einen weiteren Wert vom selben Typ wie dem Ergebnis unserer Faltoperation konsumieren.
Und dann ist da noch das <code class="language-plaintext highlighter-rouge">b</code> ‚Äúin der Mitte‚Äù - der zweite Parameter den wir <code class="language-plaintext highlighter-rouge">foldr</code> √ºbergeben m√ºssen, bevor wir es auf die Liste von <code class="language-plaintext highlighter-rouge">a</code> anwenden k√∂nnen.</p>

<p>Wie immer wird hoffentlich alles klarer wenn wir uns ein einfaches Beispiel anschauen. 
Sagen wir mal, wir m√∂chten eine Funktion <code class="language-plaintext highlighter-rouge">totalLength</code> implementieren die Anzahl aller Buchstaben in einer Liste von W√∂rter berechnet.</p>

<pre><code class="language-Elm">totalLength : List String -&gt; Int
</code></pre>

<p>In einer imperativen Sprache mit <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in"><code class="language-plaintext highlighter-rouge">for</code>-Schleife</a> k√∂nnen wir das ganze so berechnen:</p>

<pre><code class="language-JavaScript">function totalLength(words) {
  var sum = 0;
  for (let word of words) {
    sum = sum + word.length
  }
  return sum;
}

totalLength(['x', 'yy', 'zzz']) == 6 // true
</code></pre>

<p>Eine solche L√∂sung w√§re nicht zul√§ssig in Elm da wir keine <em>Variablen</em> haben deren Wert wir √ºberschreiben k√∂nnen. Deswegen gibt es auch keine <code class="language-plaintext highlighter-rouge">for</code>-Schleife in Elm. Aber <code class="language-plaintext highlighter-rouge">fold</code> erledigt den gleichen Job mindestens genauso gut. Um zu verstehen wie man <code class="language-plaintext highlighter-rouge">foldr</code> verwendet bauen wir unsere JavaScript-L√∂sung von oben wie folgt um.</p>

<p>Refaktorisierung 1:</p>

<pre><code class="language-JavaScript">function totalLength2(words) {
  var init = 0;
  var adder = 
    function(word, accu) { 
      return accu + word.length; 
    }

  var sum = init;
  for (let word of words) {
    sum = adder(word, sum);
  }
  return sum;
}
</code></pre>

<p>Refaktorisierung 2:</p>

<pre><code class="language-JavaScript">function fold(f, init, array) {
  var sum = init;
  for (let item of array) {
    sum = f(item, sum);
  }
  return sum;
}

function totalLength3(words) {
  var init = 0;
  var adder = 
    function(word, accu) { 
      return accu + word.length; 
    }
  return fold(adder, init, words);
}
</code></pre>

<p>Jetzt haben wir unsere eigene <code class="language-plaintext highlighter-rouge">fold</code>-Implementierung in JavaScript geschrieben. Und genaus wie wir sie dort verwenden rufen wir sie auch in Elm auf:</p>

<pre><code class="language-Elm">totalLength : List String -&gt; Int
totalLength words =
  let
    init = 0
    adder word accu =
      accu + (String.length word)
  in
    List.foldr adder init words
</code></pre>

<h2 id="anwendung-von-fold-in-erasecompleterows">Anwendung von <code class="language-plaintext highlighter-rouge">fold</code> in <code class="language-plaintext highlighter-rouge">eraseCompleteRows</code></h2>

<p>Die Funktion hei√üt <code class="language-plaintext highlighter-rouge">fold</code> oder <code class="language-plaintext highlighter-rouge">reduce</code> weil wir h√§ufig eine potentiell lange Liste auf einen <em>kleinen, einzelnen</em> Wert reduzieren.</p>

<p>Wie einfach der Wert ist auf den reduzieren h√§ngt von der Funktion ab mit der wir ‚Äúfalten‚Äù.
Die <a href="https://github.com/axelerator/elm-tetris/blob/74ac057b1037e10cd6c47b63647952c943054718/src/Main.elm#L396">Anwendung von <code class="language-plaintext highlighter-rouge">fold</code> in <code class="language-plaintext highlighter-rouge">eraseCompleteRows</code></a> erzeugt als R√ºckgabewert ein Paar von Listen von Reihen.</p>

<pre><code class="language-Elm">folder : Row -&gt; ( List Row, List Row ) -&gt; ( List Row, List Row )
folder ((Row fields) as row) ( nonEmptyRows, header ) =
    if isFull row then
        ( nonEmptyRows
        , mkEmptyRow (length fields) 0 :: header
        )

    else
        ( row :: nonEmptyRows
        , header
        )

( allNonEmptyRows, finalHeader ) =
    foldr folder ( [], [] ) board.rows
</code></pre>

<p>Wenn wir die Typparameter in unserem <code class="language-plaintext highlighter-rouge">foldr</code> Ausdruck auswerten ergibt das die folgenden Typen.
Ich definiere zun√§chst einen Typalias, damit alles in eine Zeile passt.</p>

<pre><code class="language-Elm">type alias RowTuple = (List Row, List Row)

foldr : ( a   -&gt;    b    -&gt;     b   )  -&gt;   b  -&gt; List  a  -&gt;    b
foldr : (Row -&gt; RowTuple -&gt; RowTuple)  -&gt;  RowTuple -&gt; List Row -&gt; RowTuple
</code></pre>

<p>Der zweite Parameter f√ºr <code class="language-plaintext highlighter-rouge">foldr</code> ist also der <code class="language-plaintext highlighter-rouge">b</code> f√ºr den ersten Aufruf unserer ‚ÄúFaltfunktion‚Äù. Jeder weitere Aufruf bekommt als <code class="language-plaintext highlighter-rouge">b</code> den R√ºckggabewert der ‚ÄúFaltfunktion‚Äù des vorherigen Listenelements.</p>

<p>Das erstemal das unsere <code class="language-plaintext highlighter-rouge">folder</code>-Funktion von aufgerufen wird:</p>

<pre><code class="language-Elm">folder : Row -&gt; ( List Row, List Row ) -&gt; ( List Row, List Row )
folder row ( nonEmptyRows, header ) = ..
</code></pre>

<p>enth√§lt <code class="language-plaintext highlighter-rouge">row</code> die erste Reihe und <code class="language-plaintext highlighter-rouge">( nonEmptyRows, header )</code> hat den Wert <code class="language-plaintext highlighter-rouge">( [], [] )</code>, denn das ist der zweite Parameter in unserem Aufruf: <code class="language-plaintext highlighter-rouge">foldr folder ( [], [] ) board.rows</code>.</p>

<ul>
  <li>Ist diese Reihe voll h√§ngen wir eine leere Reihen an den hinteren Wert des Paares.</li>
  <li>Ist die Reihe <em>nicht</em> voll, h√§ngen wir sie an den vorderen Teil des Paares.</li>
</ul>

<p>Der so berechnete R√ºckgabewert wird (neben der n√§chsten Reihe) der neue Eingabewert f√ºr den n√§chsten `folder-Aufruf. Das wird solange wiederholt bis wir alle Reihen bearbeitet haben.
Danach haben wir zwei Listen in dem Ergebnispaar: Eine mit ‚Äòunvollst√§ndigen‚Äô Reihen die den unteren Teil des Bretts bilden, und eine Liste mit leeren Reihen die wir oben drauf packen um die entfernten, vollst√§ndigen Reihen zu kompenieren.</p>

<p><img src="/assets/posts/tetris-clear-rows/fold.svg" style="width: 100%" /></p>

</section>

<div id="remark42"></div>
<script>
  var remark_config = {
    host: 'https://comments.axelerator.de',
    site_id: 'comments',
  }
</script>
<script>!function(e,n){for(var o=0;o<e.length;o++){var r=n.createElement("script"),c=".js",d=n.head||n.body;"noModule"in r?(r.type="module",c=".mjs"):r.async=!0,r.defer=!0,r.src=remark_config.host+"/web/"+e[o]+c,d.appendChild(r)}}(remark_config.components||["embed"],document);</script>


     </article>
    </main>
  </body>
  <script src="/assets/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script data-goatcounter="https://goatcounter.axelerator.de/count"
        async src="//goatcounter.axelerator.de/count.js"></script>
</html>

