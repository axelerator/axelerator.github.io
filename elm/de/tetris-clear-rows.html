<!doctype html>
<html lang="en" domain="blog.axelerator.de" >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/assets/js/highlight/styles/default.css">
    <link rel="stylesheet" href="/assets/css/tufte.min.css"/>
    <link rel="stylesheet" href="/assets/css/styles.css"/>
    <link rel="icon" type="image/png" href="/favicon.png">
    <title>Episode 10: Komplette Reihen verschwinden mit Falten</title>
  </head>
  <body class="tetris-clear-rows">
    <header>
      <div id="bg">axelerator.de</div>
      <nav>
  <div class="pages">
  
    <div><a href="/de">Home</a></div>
  
    <div><a href="/über">Über</a></div>
  
  </div>
  <div class="links">
    <a href="/feed.xml"><span class="rss"/></a>
    <a href="https://twitter.com/TheAxelerator"><span class="twitter"/></a>
    <a href="https://hachyderm.io/@axelerator"><span class="fediverse"/></a>
    <a href="https://github.com/axelerator"><span class="github"/></a>
    <a href="https://www.linkedin.com/in/axel-tetzlaff"><span class="linkedin"/></a>
    <a href="https://www.youtube.com/channel/UCQFzW6LFfreLOYI9-3QV2xg"><span class="youtube"/></a>
    <a href="https://www.twitch.tv/programmingisfun"><span class="twitch"/></a>
  </div>
  <div id="lang-picker">
    <label class="current" for="lang-toggle">🇩🇪</label>
    <input type="checkbox" id="lang-toggle">
    <ul>
      
      
        
      
        
          <li>
            <a href="/elm/en/tetris-clear-rows" class="en">🇺🇸</a>
          </li>
        
      
    </ul>

  </div>

</nav>




    </header>
    <main>
     <article>
       <h1>Episode 10: Komplette Reihen verschwinden mit Falten</h1>
       <div class="meta"> 
  <div title="Lesedauer">4 Minuten</div>
  <div>
  
    
    <a href="/tags#elm">#elm</a>
  
  </div>
  <div>16 September 2021</div>
</div>


<section>
<p><img src="/assets/posts/tetris-clear-rows/teaser.gif" style="float:left; margin: 5px 10px 10px 0" />
Damit mein Tetris spielbar wird sorge ich in <a href="https://www.youtube.com/watch?v=b1vnT6XTFP4">Episode 10 (55min)</a> 
dafür, dass vollständige Zeilen verschwinden. Mit mehr Unit-Tests und der Anwendung der Faltung einer Liste nähere ich mich einem vollständigen Version.</p>

<p>Die Code-Änderungen von dieser Woche gibt es im <a href="https://github.com/axelerator/elm-tetris/tree/episode10">episode10 Branch</a> bzw <a href="https://github.com/axelerator/elm-tetris/commit/74ac057b1037e10cd6c47b63647952c943054718">Commit</a>.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/b1vnT6XTFP4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Es ist immer sehr befriedigend wenn man sich einen Plan zurechtlegt und die Ausführung dann auch einigermaßen danach abläuft.
Dementsprechend hat die Aufzeichnung dieser Episode auch Spaß gemacht. Die initiale Idee war es die <code class="language-plaintext highlighter-rouge">eraseCompleteRows</code> zu entwickeln, welche ein Board von den vollständigen Reihen befreien sollte.</p>

<p>Da ich bereits in <a href="/elm/de/tetris-collision">Episode 7</a> ein Setup für automatisierte Tests eingerichtet hatte, fiel die Entscheidung nicht schwer diesmal gleich mit einem Test loszulegen.</p>

<p>Der Algorithmus für den ich mich am Ende entschieden habe läuft wie folgt ab:</p>

<ol>
  <li>Durchlaufe alle Zeilen des Spielbretts:
    <ul>
      <li><em>1a</em> für eine <strong>unvollständige</strong> Reihe: Sammele sie als <em>“Boden”</em>-Reihe für das Folgespielbrett</li>
      <li><em>1b</em> für eine <strong>vollständige</strong> Reihe: Sammel eine leere <em>“Kopf”</em>-Reihe in einer Extra-Liste</li>
    </ul>
  </li>
  <li>Erstelle das Folgespielbrett mit den <em>“Boden”</em>-Reihen (1a) unten und hänge die <em>“Kopf”</em>-Reihen (1b) darüber.</li>
</ol>

<p>Bei der Implementierung habe ich mich für die Nutzung der <code class="language-plaintext highlighter-rouge">foldr</code> Funktion entschieden. Da einige Programmierer Angst vor dieser Funktion zu haben scheinen möchte ich hier die Gelegenheit nutzen ein paar Unklarheiten zu breinigen.</p>

<h3 id="wofür-ist-foldr-gut">Wofür ist <code class="language-plaintext highlighter-rouge">foldr</code> gut?</h3>

<p><code class="language-plaintext highlighter-rouge">foldr</code> existiert in vielen Sprachen, sie heißt nur manchmal anders:</p>

<ul>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reduce</a> in JavaScript</li>
  <li><a href="https://ruby-doc.org/core-3.0.2/Enumerable.html#method-i-inject">inject</a> in Ruby</li>
</ul>

<p>Ähnlich wie <code class="language-plaintext highlighter-rouge">map</code> können wir <code class="language-plaintext highlighter-rouge">fold</code> eine Funktion als Parameter übergeben, die für jedes Element ausgeführt wird. Im Gegensatz zu <code class="language-plaintext highlighter-rouge">map</code> braucht das Ergebnis allerdings nicht zwingend eine Liste zu sein, sonder kann von einem beliebigem Typ sein.
In diesem Sinne ist <code class="language-plaintext highlighter-rouge">fold</code> also <em>“mächtiger”</em> als <code class="language-plaintext highlighter-rouge">map</code>.</p>

<p>Diese Macht erkaufen wir uns allerdings auch mit etwas mehr Komplexität. Vergleichen wir einmal die Signaturen von <code class="language-plaintext highlighter-rouge">map</code> und <code class="language-plaintext highlighter-rouge">foldr</code>:</p>

<pre><code class="language-Elm">map :   (a -&gt; b)             -&gt; List a -&gt; List b

foldr : (a -&gt; b -&gt; b)  -&gt;  b -&gt; List a -&gt; b
</code></pre>

<p><code class="language-plaintext highlighter-rouge">map</code> ist einfach: Es verwandelt eine Liste von Elementen vom typ <code class="language-plaintext highlighter-rouge">a</code> in eine gleich lange Liste von Elementen vom Typ <code class="language-plaintext highlighter-rouge">b</code>. Dafür verwendet <code class="language-plaintext highlighter-rouge">map</code> die Funktion <code class="language-plaintext highlighter-rouge">(a -&gt; b)</code> die wir übergeben.</p>

<p>Ich habe die einzelnen Parameter in Signaturen bewusst ausgerichtet um die Unterschiede zu verdeutlichen.
Für <code class="language-plaintext highlighter-rouge">fold</code> taucht <code class="language-plaintext highlighter-rouge">b</code> jetzt an viel mehr Stellen auf! 
Der Rückgabewert ist jetzt nur noch <code class="language-plaintext highlighter-rouge">b</code> anstatt <code class="language-plaintext highlighter-rouge">List b</code>!
Unsere “Faltfunktion” ist nicht mehr <code class="language-plaintext highlighter-rouge">(a -&gt; b)</code> sondern <code class="language-plaintext highlighter-rouge">(a -&gt; b -&gt; b)</code>. Das heißt um den Rückggabewert <em>pro Element</em> zu berechnen müssen wir zusätzlich einen weiteren Wert vom selben Typ wie dem Ergebnis unserer Faltoperation konsumieren.
Und dann ist da noch das <code class="language-plaintext highlighter-rouge">b</code> “in der Mitte” - der zweite Parameter den wir <code class="language-plaintext highlighter-rouge">foldr</code> übergeben müssen, bevor wir es auf die Liste von <code class="language-plaintext highlighter-rouge">a</code> anwenden können.</p>

<p>Wie immer wird hoffentlich alles klarer wenn wir uns ein einfaches Beispiel anschauen. 
Sagen wir mal, wir möchten eine Funktion <code class="language-plaintext highlighter-rouge">totalLength</code> implementieren die Anzahl aller Buchstaben in einer Liste von Wörter berechnet.</p>

<pre><code class="language-Elm">totalLength : List String -&gt; Int
</code></pre>

<p>In einer imperativen Sprache mit <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in"><code class="language-plaintext highlighter-rouge">for</code>-Schleife</a> können wir das ganze so berechnen:</p>

<pre><code class="language-JavaScript">function totalLength(words) {
  var sum = 0;
  for (let word of words) {
    sum = sum + word.length
  }
  return sum;
}

totalLength(['x', 'yy', 'zzz']) == 6 // true
</code></pre>

<p>Eine solche Lösung wäre nicht zulässig in Elm da wir keine <em>Variablen</em> haben deren Wert wir überschreiben können. Deswegen gibt es auch keine <code class="language-plaintext highlighter-rouge">for</code>-Schleife in Elm. Aber <code class="language-plaintext highlighter-rouge">fold</code> erledigt den gleichen Job mindestens genauso gut. Um zu verstehen wie man <code class="language-plaintext highlighter-rouge">foldr</code> verwendet bauen wir unsere JavaScript-Lösung von oben wie folgt um.</p>

<p>Refaktorisierung 1:</p>

<pre><code class="language-JavaScript">function totalLength2(words) {
  var init = 0;
  var adder = 
    function(word, accu) { 
      return accu + word.length; 
    }

  var sum = init;
  for (let word of words) {
    sum = adder(word, sum);
  }
  return sum;
}
</code></pre>

<p>Refaktorisierung 2:</p>

<pre><code class="language-JavaScript">function fold(f, init, array) {
  var sum = init;
  for (let item of array) {
    sum = f(item, sum);
  }
  return sum;
}

function totalLength3(words) {
  var init = 0;
  var adder = 
    function(word, accu) { 
      return accu + word.length; 
    }
  return fold(adder, init, words);
}
</code></pre>

<p>Jetzt haben wir unsere eigene <code class="language-plaintext highlighter-rouge">fold</code>-Implementierung in JavaScript geschrieben. Und genaus wie wir sie dort verwenden rufen wir sie auch in Elm auf:</p>

<pre><code class="language-Elm">totalLength : List String -&gt; Int
totalLength words =
  let
    init = 0
    adder word accu =
      accu + (String.length word)
  in
    List.foldr adder init words
</code></pre>

<h2 id="anwendung-von-fold-in-erasecompleterows">Anwendung von <code class="language-plaintext highlighter-rouge">fold</code> in <code class="language-plaintext highlighter-rouge">eraseCompleteRows</code></h2>

<p>Die Funktion heißt <code class="language-plaintext highlighter-rouge">fold</code> oder <code class="language-plaintext highlighter-rouge">reduce</code> weil wir häufig eine potentiell lange Liste auf einen <em>kleinen, einzelnen</em> Wert reduzieren.</p>

<p>Wie einfach der Wert ist auf den reduzieren hängt von der Funktion ab mit der wir “falten”.
Die <a href="https://github.com/axelerator/elm-tetris/blob/74ac057b1037e10cd6c47b63647952c943054718/src/Main.elm#L396">Anwendung von <code class="language-plaintext highlighter-rouge">fold</code> in <code class="language-plaintext highlighter-rouge">eraseCompleteRows</code></a> erzeugt als Rückgabewert ein Paar von Listen von Reihen.</p>

<pre><code class="language-Elm">folder : Row -&gt; ( List Row, List Row ) -&gt; ( List Row, List Row )
folder ((Row fields) as row) ( nonEmptyRows, header ) =
    if isFull row then
        ( nonEmptyRows
        , mkEmptyRow (length fields) 0 :: header
        )

    else
        ( row :: nonEmptyRows
        , header
        )

( allNonEmptyRows, finalHeader ) =
    foldr folder ( [], [] ) board.rows
</code></pre>

<p>Wenn wir die Typparameter in unserem <code class="language-plaintext highlighter-rouge">foldr</code> Ausdruck auswerten ergibt das die folgenden Typen.
Ich definiere zunächst einen Typalias, damit alles in eine Zeile passt.</p>

<pre><code class="language-Elm">type alias RowTuple = (List Row, List Row)

foldr : ( a   -&gt;    b    -&gt;     b   )  -&gt;   b  -&gt; List  a  -&gt;    b
foldr : (Row -&gt; RowTuple -&gt; RowTuple)  -&gt;  RowTuple -&gt; List Row -&gt; RowTuple
</code></pre>

<p>Der zweite Parameter für <code class="language-plaintext highlighter-rouge">foldr</code> ist also der <code class="language-plaintext highlighter-rouge">b</code> für den ersten Aufruf unserer “Faltfunktion”. Jeder weitere Aufruf bekommt als <code class="language-plaintext highlighter-rouge">b</code> den Rückggabewert der “Faltfunktion” des vorherigen Listenelements.</p>

<p>Das erstemal das unsere <code class="language-plaintext highlighter-rouge">folder</code>-Funktion von aufgerufen wird:</p>

<pre><code class="language-Elm">folder : Row -&gt; ( List Row, List Row ) -&gt; ( List Row, List Row )
folder row ( nonEmptyRows, header ) = ..
</code></pre>

<p>enthält <code class="language-plaintext highlighter-rouge">row</code> die erste Reihe und <code class="language-plaintext highlighter-rouge">( nonEmptyRows, header )</code> hat den Wert <code class="language-plaintext highlighter-rouge">( [], [] )</code>, denn das ist der zweite Parameter in unserem Aufruf: <code class="language-plaintext highlighter-rouge">foldr folder ( [], [] ) board.rows</code>.</p>

<ul>
  <li>Ist diese Reihe voll hängen wir eine leere Reihen an den hinteren Wert des Paares.</li>
  <li>Ist die Reihe <em>nicht</em> voll, hängen wir sie an den vorderen Teil des Paares.</li>
</ul>

<p>Der so berechnete Rückgabewert wird (neben der nächsten Reihe) der neue Eingabewert für den nächsten `folder-Aufruf. Das wird solange wiederholt bis wir alle Reihen bearbeitet haben.
Danach haben wir zwei Listen in dem Ergebnispaar: Eine mit ‘unvollständigen’ Reihen die den unteren Teil des Bretts bilden, und eine Liste mit leeren Reihen die wir oben drauf packen um die entfernten, vollständigen Reihen zu kompenieren.</p>

<p><img src="/assets/posts/tetris-clear-rows/fold.svg" style="width: 100%" /></p>

</section>

<div id="remark42"></div>
<script>
  var remark_config = {
    host: 'https://comments.axelerator.de',
    site_id: 'comments',
  }
</script>
<script>!function(e,n){for(var o=0;o<e.length;o++){var r=n.createElement("script"),c=".js",d=n.head||n.body;"noModule"in r?(r.type="module",c=".mjs"):r.async=!0,r.defer=!0,r.src=remark_config.host+"/web/"+e[o]+c,d.appendChild(r)}}(remark_config.components||["embed"],document);</script>


     </article>
    </main>
  </body>
  <script src="/assets/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script data-goatcounter="https://goatcounter.axelerator.de/count"
        async src="//goatcounter.axelerator.de/count.js"></script>
</html>

