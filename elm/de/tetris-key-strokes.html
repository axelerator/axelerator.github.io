<!doctype html>
<html lang="en" domain="blog.axelerator.de" >
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/assets/js/highlight/styles/default.css">
    <link rel="stylesheet" href="/assets/css/tufte.min.css"/>
    <link rel="stylesheet" href="/assets/css/styles.css"/>
    <link rel="icon" type="image/png" href="/favicon.png">
    <title>Episode 5: Registrierung von Tastendruck</title>
  </head>
  <body class="tetris-key-strokes">
    <header>
      <div id="bg">axelerator.de</div>
      <nav>
  <div class="pages">
  
    <div><a href="/de">Home</a></div>
  
    <div><a href="/√ºber">√úber</a></div>
  
  </div>
  <div class="links">
    <a href="/feed.xml"><span class="rss"/></a>
    <a href="https://twitter.com/TheAxelerator"><span class="twitter"/></a>
    <a href="https://hachyderm.io/@axelerator"><span class="fediverse"/></a>
    <a href="https://github.com/axelerator"><span class="github"/></a>
    <a href="https://www.linkedin.com/in/axel-tetzlaff"><span class="linkedin"/></a>
    <a href="https://www.youtube.com/channel/UCQFzW6LFfreLOYI9-3QV2xg"><span class="youtube"/></a>
    <a href="https://www.twitch.tv/programmingisfun"><span class="twitch"/></a>
  </div>
  <div id="lang-picker">
    <label class="current" for="lang-toggle">üá©üá™</label>
    <input type="checkbox" id="lang-toggle">
    <ul>
      
      
        
      
        
          <li>
            <a href="/elm/en/tetris-key-strokes" class="en">üá∫üá∏</a>
          </li>
        
      
    </ul>

  </div>

</nav>




    </header>
    <main>
     <article>
       <h1>Episode 5: Registrierung von Tastendruck</h1>
       <div class="meta"> 
  <div title="Lesedauer">6 Minuten</div>
  <div>
  
    
    <a href="/tags#elm">#elm</a>
  
  </div>
  <div>13 August 2021</div>
</div>


<section>
<p>In <a href="https://www.youtube.com/watch?v=JG3zzF_jRVc&amp;t=1013s">dieser Episode (40min)</a> schauen wir uns an wie wir auf globale Tastaturereignisse reagieren. Wir bem√ºhen ein weiteres mal das <em>Subscription-System</em> welches wir <a href="/elm/en/tetris-gravity">letztes mal</a> kennengelernt haben.</p>

<p>In dieser Nachbereitung gehe ich nocheinmal auf die folgenden Themen ein:</p>

<ol>
  <li><a href="#subs">Stapeln von mehreren Subscriptions</a></li>
  <li><a href="#parsing">Warum ist JSON Parsen/Dekodieren in Elm so kompliziert?</a></li>
  <li><a href="#decoder">Wie funktioniert unser <code class="language-plaintext highlighter-rouge">keyDecoder</code>?</a></li>
</ol>

<iframe width="560" height="315" src="https://www.youtube.com/embed/JG3zzF_jRVc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<p>Den Code von dieser Episode gibt es auf Github: <a href="https://github.com/axelerator/elm-tetris/tree/episode5">Branch Episode5</a> <a href="https://github.com/axelerator/elm-tetris/commit/ff76dcab313f67bd8e878857dfa8cd0af18e2c53">Commit</a></p>

<h3 id="stapeln-von-subscriptions"><a name="subs"></a>Stapeln von Subscriptions</h3>

<p>Wie wir bereits letzte Episode gesehen haben geh√∂ren die <code class="language-plaintext highlighter-rouge">subscriptions</code> zu den Ausdr√ºcken die wir als Teil unserer ‚ÄòAnwendungswurzel‚Äô deklarieren</p>

<pre><code class="language-Elm">main =
    Browser.element
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }

subscriptions : Model -&gt; Sub Msg
subscriptions model = ..
</code></pre>

<p>Die erwartete Signatur ist sehr explizit dar√ºber, dass sie genau <strong>eine</strong> <code class="language-plaintext highlighter-rouge">Sub Msg</code> erwartet. Wir haben aber bereits in der letzten Episode eine Subscription f√ºr die Gravitation registriert:</p>

<pre><code class="language-Elm">subscriptions : Model -&gt; Sub Msg
subscriptions model =
    Time.every 1000 GravityTick
</code></pre>

<p>Wie ich im Video zeige k√∂nnen wir den Ausdruck nicht einfach in eine Liste umwandeln. Der Ausdruck <code class="language-plaintext highlighter-rouge">[Time.every 1000 GravityTick, onKeyDown keyDecoder]</code> hat den Typ <code class="language-plaintext highlighter-rouge">List (Sub Msg)</code>. Das ist nicht kompatibel mit dem erwarteten <code class="language-plaintext highlighter-rouge">Sub Msg</code>.</p>

<p>Um dies zu umgehen nutzen wir die <a href="https://package.elm-lang.org/packages/elm/core/latest/Platform-Sub#batch"><code class="language-plaintext highlighter-rouge">batch</code></a> Funktion. Mit dieser k√∂nnen wir mehrere Subscriptions in eine einzelne ‚Äúeinwickeln‚Äù. Dies Funktioniert auch mehrfach. Das hei√üt ein ‚Äúbatch‚Äù kann wiederum mehrere ‚Äúbatches‚Äù enthalten. Hauptsache wir haben am Ende eine <strong>einzelne</strong> Subscription die wir ‚Äúanmelden‚Äù k√∂nnen.</p>

<p>Die finale L√∂sung sieht in unserem Fall so aus:</p>

<pre><code class="language-Elm">subscriptions : Model -&gt; Sub Msg
subscriptions model =
    Sub.batch
        [ Time.every 1000 GravityTick
        , onKeyDown keyDecoder
        ]
</code></pre>

<h3 id="warum-ist-json-parsendekodieren-in-elm-so-kompliziert"><a name="parsing"></a>Warum ist JSON Parsen/Dekodieren in Elm so kompliziert?</h3>

<p>Wie bereits im Video erw√§hnt werde ich hier nicht versuchen eine vollst√§ndige Einf√ºhrung in JSON-Verarbeitung zu geben.
Im offiziellen Elm Guide gibt es eine <a href="https://guide.elm-lang.org/effects/json.html">kurze Einf√ºhrung</a> die jedoch kompliziertere F√§lle offen l√§sst.
F√ºr weiterf√ºhrende Anleitungen gibt es bereits zahlreiche Artikel online wie zum Beispiel auf <a href="https://elmprogramming.com/decoding-json-part-1.html#decoding-json">elmprogramming.com</a></p>

<p>Verglichen zu Sprachen mit weniger eingebauten Garantien erscheint der Ansatz von Elm zun√§chst unn√∂tig kompliziert und unintuitiv.</p>

<p>Ich habe am Anfang ziemlich damit gek√§mpft und hoffe das ich mit der kleinen Zusammenfassung hier zeigen kann, dass sich der Aufwand lohnt.</p>

<p>Am Ende dieser Episode haben wir einen JSON Decoder der wie folgt definiert ist:</p>

<pre><code class="language-Elm">keyDecoder : Decode.Decoder Msg
keyDecoder =
    Decode.map toKey (Decode.field "key" Decode.string)

toKey : String -&gt; Msg
toKey string =
    case string of
        "ArrowLeft" -&gt;
            KeyDown LeftArrow

        ... -&gt; ...
</code></pre>

<p>Die <a href="https://github.com/axelerator/elm-tetris/blob/ff76dcab313f67bd8e878857dfa8cd0af18e2c53/src/Main.elm#L246"><code class="language-plaintext highlighter-rouge">toKey</code></a> ist trivial, denn sie wandelt lediglich eine Zeichenkette in eine <code class="language-plaintext highlighter-rouge">Msg</code> um.
Aber der <code class="language-plaintext highlighter-rouge">keyDecoder</code> hat es in sich! Um ihn besser zu Verstehen schauen wir erstmal was ein <strong>Decoder</strong> ist.
Die Elm Dokumentation sagt dazu:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">type Decoder a</code><br />
A value that knows how to decode JSON values.</p>
</blockquote>

<p>Und schickt uns in den <a href="https://guide.elm-lang.org/effects/json.html">offiziellen Guide</a> f√ºr mehr Details.
Ich versuche eine alternative Erkl√§rung zu geben die hoffentlich ein paar Fragen beantwortet die Entwickler haben die aus weniger ‚Äòfunktionalen Umgebungen‚Äô kommen.</p>

<p>Ein <code class="language-plaintext highlighter-rouge">Decoder</code> ist also ‚ÄúEin Wert der wei√ü wie JSON Werte zu dekodieren sind‚Äù. Das erste was auff√§llt ist, dass unser <code class="language-plaintext highlighter-rouge">keyDecoder</code> keinen Parameter animmt. Das ist im Sinne der Definition, denn wir berechnen nicht einen Wert aus gegebenen Parametern sondern geben einen konstanten Ausdruck zur√ºck.</p>

<p>Das bringt die Frage auf: ‚ÄúWie kann ein <strong>konstanter Wert</strong> etwas dekodieren?‚Äù
Das bringt uns zu den Grundprinzipien der funktionalen Programmierung zur√ºck: Funktionen <strong>sind</strong> Werte.
In der Dokumentation sehen wir lediglich die ‚Äòlinke Seite‚Äô der Typdefintion. 
Es kann also durchaus sein, dass dieser Typ aus Varianten gebildet die eine Funktion enthalten.</p>

<p>Die <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode">Decoder-Bibliothek</a> enth√§lt eine handvoll vordefinierter <code class="language-plaintext highlighter-rouge">Decoder</code> und Funktionen mit denen wir diese zu komplexeren Dekodierern zusammensetzen k√∂nnen.</p>

<p>Ein Typ dessen ‚Äúrechte‚Äù Seite der Definition <code class="language-plaintext highlighter-rouge">type Decoder a = ???</code> wir nicht kennen wird auch ein <strong>opaquer Typ</strong> genannt.
Das hei√üt der Entwickler dieses Typs m√∂chte nicht, dass wir die Implementierungsdetails kennen. Auf den ersten Blick mag das unn√∂tig einschr√§nkend wirken.
Richtig eingesetzt sind opaque Typen aber extrem <strong>befreiend</strong>. Es bedeutet, dass ich als Anwedungsentwickler mich nicht unn√∂tig mit Implementierungsdetails auseinanderzusetzen brauch. Und da ich mit diesem Teil des Systems nicht interagieren kann, kann ich es auch nicht ‚Äòfalsch bedienen‚Äô oder kaputt machen.</p>

<p>Anhand unseres <code class="language-plaintext highlighter-rouge">keyDecoder</code> werden wir sehen wir ein solcher Typ, obwohl wir nichts √ºber seine Interna wissen, dennoch sehr n√ºtzlich sein kann.</p>

<p>Um <code class="language-plaintext highlighter-rouge">Decoder</code> besser zu verstehen schauen wir uns zun√§chst einmal an wie er unabh√§ngig von der Tastaturerignisverwaltung eingesetzt werden kann. 
Zur Erinnerung nocheinmal die Definition:</p>

<pre><code class="language-Elm">keyDecoder : Decode.Decoder Msg
keyDecoder =
    Decode.map toKey (Decode.field "key" Decode.string)
</code></pre>

<p>Das folgende ist ein komplettes Beispiel um eine JSON Zeichenkette mit Hilfe unseres <code class="language-plaintext highlighter-rouge">keyDecoder</code> in eine Msg umzuwandeln.
Der zentrale Aufruf ist die Funktion <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#decodeString"><code class="language-plaintext highlighter-rouge">Decode.decodeString</code></a> die einen <code class="language-plaintext highlighter-rouge">Decoder</code> und einen <code class="language-plaintext highlighter-rouge">String</code> erwartet und versucht einen Wert des Zieldatentypen (<code class="language-plaintext highlighter-rouge">Msg</code>) zu erzeugen.</p>

<pre><code class="language-Elm">eventJsonToKeyMsg : Msg
eventJsonToKeyMsg jsonString =
    let
        jsonString =
            "{ \"key\" : \"ArrowLeft\"}"
        
        parseResult =
            Decode.decodeString keyDecoder jsonString
    in
    case parseResult of
        Ok msg -&gt;
            msg
        Err e -&gt; 
          let
            _ = Debug.log "invalid" (Decode.errorToString e)
          in
            Noop
</code></pre>

<p>Die JSON Bibliothek ist ein gutes Beispiel f√ºr das <a href="https://en.wikipedia.org/wiki/Separation_of_concerns">‚ÄúSeparation of concerns‚Äù Prinzip</a>.
Die Funktionen die wissen wie man ein <code class="language-plaintext highlighter-rouge">String</code>-Wert aus eine JSON-Objekt extrahiert sind in dem opaquen <code class="language-plaintext highlighter-rouge">Decoder</code> Typ weggekapselt.
Unsere Definition welche <strong>Struktur</strong> wir uns von dem JSON ‚Äòw√ºnschen‚Äô kommt ohne jegliches Wissen aus wie JSON das JSON Verarbeitet wird. Diese Definition ist desweiteren komplett getrennt von der tats√§chlichen <strong>Ausf√ºhrung</strong>.</p>

<p>Der Hauptvorteil dieser strikten Trennung kommt zum Vorschein wenn wir versuchen ein unvollst√§ndiges JSON zu parsen.
<code class="language-plaintext highlighter-rouge">decodeString</code> kann nicht garantieren das wir ein <code class="language-plaintext highlighter-rouge">Msg</code> Wert aus der Zeichenkette erzeugen k√∂nnen.</p>

<p>Wenn wir einen Tipfehler in unser JSON einbauen (<code class="language-plaintext highlighter-rouge">key -&gt; keX</code>):</p>

<pre><code class="language-Elm">  jsonString =
      "{ \"keX\" : \"ArrowLeft\"}"
</code></pre>

<p>Laufen wir in den <code class="language-plaintext highlighter-rouge">Err e -&gt; ...</code> Fall und bekommen wir folgende Ausgabe in der JavaScript Konsole folgende Ausgabe:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>invalid: "Problem with the given value:
  { \"keX\": \"ArrowLeft\" }
Expecting an OBJECT with a field named `key`"
</code></pre></div></div>
<p>Das hei√üt sobald wir unseren <code class="language-plaintext highlighter-rouge">Decoder</code> spezifiziert haben</p>

<ul>
  <li>zwingt uns das Typsystem Parserfehler explizit zu behandeln</li>
  <li>gibt uns im Fehlerfall sehr genaue Beschreibung wo das Problem liegt</li>
</ul>

<p>Bei so einfachem JSON wie in unserem Beispiel ist dies offensichtlich nicht n√∂tig. Bei Realwelt-APIs die kontinuierlichen √Ñnderungen unterliegen ist dieses Verhalten jedoch sehr wertvoll.</p>

<h3 id="wie-funktioniert-unser-keydecoder"><a name="decoder"></a>Wie funktioniert unser <code class="language-plaintext highlighter-rouge">keyDecoder</code>?</h3>

<p>Im Video habe ich die Definition von <code class="language-plaintext highlighter-rouge">keyDecoder</code> fast 1:1 aus dem <a href="https://github.com/elm/browser/blob/1.0.2/notes/keyboard.md">Beispiel</a> kopiert.
Um ihn besser zu Verstehen k√∂nnen wir unsere Definition wie folg aufbrechen ohne die Funktion zu ver√§ndern:</p>

<pre><code class="language-Elm">keyDecoder : Decode.Decoder Msg
keyDecoder = Decode.map toKey keyNameDecoder

keyNameDecoder : Decode.Decoder String
keyNameDecoder = Decode.field "key" Decode.string
</code></pre>

<p>Die ausgeglierderte <code class="language-plaintext highlighter-rouge">keyNameDecoder</code> Hilfsfunktion ist jetzt ein Dekodierer der aus einem JSON Objekt ein String auslesen m√∂chte.
Wenn er ausgef√ºhrt wird sucht er nach dem Wert der unter dem Schl√ºssel <code class="language-plaintext highlighter-rouge">key</code> hinterlegt ist.
Ist dieser nicht vorhanden oder nicht vom Typ <code class="language-plaintext highlighter-rouge">String</code> wird die Dekodierung fehlschlagen.</p>

<p>Der magische Kleber hier ist allerdings die <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#map"><code class="language-plaintext highlighter-rouge">Decode.map</code> Funktion</a></p>

<pre><code class="language-Elm">map : (a -&gt; value) -&gt; Decoder a -&gt; Decoder value`
</code></pre>

<p>Zum besseren Verst√§ndnis setzen wir die Typen aus unserem <code class="language-plaintext highlighter-rouge">keyDecoder</code> als Typparameter (<code class="language-plaintext highlighter-rouge">a</code> und <code class="language-plaintext highlighter-rouge">value</code>) ein.</p>

<pre><code class="language-Elm">map : (String -&gt; Msg) -&gt; Decoder String  -&gt; Decoder Msg`
</code></pre>

<p>So liest sich der Aufruf nun:</p>

<p><code class="language-plaintext highlighter-rouge">map</code> erwartet zwei Parameter:</p>
<ol>
  <li>Eine Funktion die aus einem <code class="language-plaintext highlighter-rouge">String</code> eine <code class="language-plaintext highlighter-rouge">Msg</code> erzeugt (<code class="language-plaintext highlighter-rouge">toKey</code>)</li>
  <li>Ein Dekodierer der aus einem JSON Objekt einen <code class="language-plaintext highlighter-rouge">String</code> ausliest (<code class="language-plaintext highlighter-rouge">keyNameDecoder</code>)
Das Ergebnis ist ein <code class="language-plaintext highlighter-rouge">Decoder Msg</code> der aus einem JSON Objekt ein <code class="language-plaintext highlighter-rouge">Msg</code> Wert erzeugen kann.</li>
</ol>

<p>Das wirft nat√ºrlich direkt die Frage auf wie wir Werte f√ºr Typen erzeugen die <strong>mehr</strong> als einen Parameter erwarten.
Daf√ºr gibt es die Funktionen <code class="language-plaintext highlighter-rouge">map2</code> bis <code class="language-plaintext highlighter-rouge">map8</code>. Das Beispiel in der <a href="https://package.elm-lang.org/packages/elm/json/latest/Json-Decode#map2">Dokumentation</a> f√ºr <code class="language-plaintext highlighter-rouge">map2</code> dekodiert einen <code class="language-plaintext highlighter-rouge">Point</code>-Wert der ein <code class="language-plaintext highlighter-rouge">x</code> und ein <code class="language-plaintext highlighter-rouge">y</code> erwartet.</p>

<pre><code class="language-Elm">type alias Point = { x : Float, y : Float }

point : Decoder Point
point =
  map2 Point
    (field "x" float)
    (field "y" float)
</code></pre>

<p>F√ºr komplexere Strukturen lohnt sich jedoch der Einsatz der <a href="https://package.elm-lang.org/packages/NoRedInk/elm-json-decode-pipeline/latest">externen Bibliothek <code class="language-plaintext highlighter-rouge">elm-json-decode-pipeline</code></a>. Sie stellt alternative Kombinationsfunktionen zur Verf√ºgung die die <code class="language-plaintext highlighter-rouge">mapN</code> Funktionen etwas eleganter ersetzen.</p>


</section>

<div id="remark42"></div>
<script>
  var remark_config = {
    host: 'https://comments.axelerator.de',
    site_id: 'comments',
  }
</script>
<script>!function(e,n){for(var o=0;o<e.length;o++){var r=n.createElement("script"),c=".js",d=n.head||n.body;"noModule"in r?(r.type="module",c=".mjs"):r.async=!0,r.defer=!0,r.src=remark_config.host+"/web/"+e[o]+c,d.appendChild(r)}}(remark_config.components||["embed"],document);</script>


     </article>
    </main>
  </body>
  <script src="/assets/js/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script data-goatcounter="https://goatcounter.axelerator.de/count"
        async src="//goatcounter.axelerator.de/count.js"></script>
</html>

